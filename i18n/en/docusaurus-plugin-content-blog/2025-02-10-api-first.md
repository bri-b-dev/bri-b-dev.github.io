---

slug: api-first-springboot-kotlin
title: "API-First wotj Spring Boot & Kotlin"
authors: brigitte
tags: [spring-boot, kotlin, openapi, microservices, codegen, api-first]
date: 2025-02-10
description: "How I design microservices according to OpenAPI and automatically generate clients & server stubs ‚Äì Lessons learned in Kotlin."
---

import Admonition from '@theme/Admonition';

Microservices should offer **consistent interfaces** ‚Äì regardless of the programming language.
API-first means: **first the OpenAPI schema**, then code, documentation, and clients.
<!--truncate-->
This prevents API definitions from becoming outdated or being added as an ‚Äúafterthought.‚Äù

---

## üß© Workflow: API-First in practice

1. **Design**: OpenAPI spec (`.yaml`) with Stoplight, Swagger Editor, or VS Code plugin.
2. **Validate**: Linter (e.g., Spectral) and CI checks.
3. **Codegen**: Generate server stubs & client SDKs from the spec.
4. **Implement**: Business logic in Kotlin, interface remains stable.
5. **Docs**: Swagger UI or ReDoc from the same spec.

---

## ‚öôÔ∏è Setup: OpenAPI Generator in Kotlin

**`build.gradle.kts`**

```kotlin
plugins {
    id("org.springframework.boot") version "3.3.0"
    id("io.spring.dependency-management") version "1.1.5"
    kotlin("jvm") version "1.9.24"
    kotlin("plugin.spring") version "1.9.24"
    id("org.openapi.generator") version "7.5.0"
}

openApiGenerate {
    generatorName.set("kotlin-spring")
    inputSpec.set("$rootDir/api/openapi.yaml")
    outputDir.set("$buildDir/generated")
    apiPackage.set("com.example.api")
    modelPackage.set("com.example.api.model")
    configOptions.set(
        mapOf(
            "interfaceOnly" to "true",
            "useSpringBoot3" to "true",
            "reactive" to "false"
        )
    )
}
```

üëâ Result:

* **API interfaces** as Kotlin interfaces (controller skeletons)
* **DTOs** in the `model` package

---

## üöß Lessons Learned

### 1. Interface-only is worth its weight in gold

* Only generate interfaces; implementation remains **clean in your own code**.
* No merge conflicts when regenerating.

### 2. Use DTOs strictly

* DTOs from `model` are **transport objects**‚Äînot business entities.
* Avoid ‚Äúsmart‚Äù logic in DTOs, keep them flat.

### 3. Versioning & backward compatibility

* Version OpenAPI as a **single source of truth** in Git.
* Breaking changes only with new API version (`/v2/...`).

### 4. CI/CD checks

* Validate OpenAPI spec in every PR (`spectral lint`).
* Check codegen in CI to ensure everything is up to date (`git diff` on generated code).

---

## üì¶ Client generation

OpenAPI Generator can also be used to create **clients** for other languages:

```bash
openapi-generator-cli generate \
  -i api/openapi.yaml \
  -g typescript-fetch \
  -o clients/ts
```

* Frontend uses `typescript-fetch` or `typescript-axios`.
* Other services can obtain `java`, `python`, `go` SDKs.
* Uniform API guarantees consistency across the stack.

---

## üîó Mini example: User API end-to-end

### 1. OpenAPI Spec (abridged)

**`api/openapi.yaml`**

```yaml
openapi: 3.0.3
info:
  title: User API
  version: 1.0.0
paths:
  /users/{id}:
    get:
      summary: Get user by ID
      parameters:
        - in: path
          name: id
          required: true
          schema:
            type: string
            format: uuid
      responses:
        '200':
          description: OK
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/User'
        '404':
          description: Not Found
components:
  schemas:
    User:
      type: object
      properties:
        id:
          type: string
          format: uuid
        name:
          type: string
```

### 2. Generated interface (abridged)

**`build/generated/com/example/api/UsersApi.kt`**

```kotlin
package com.example.api

import com.example.api.model.User
import org.springframework.http.ResponseEntity
import org.springframework.web.bind.annotation.PathVariable

interface UsersApi {
    fun getUserById(@PathVariable("id") id: java.util.UUID): ResponseEntity<User>
}
```

### 3. Kotlin implementation

**`src/main/kotlin/com/example/controller/UserController.kt`**

```kotlin
package com.example.controller

import com.example.api.UsersApi
import com.example.api.model.User
import org.springframework.http.ResponseEntity
import org.springframework.web.bind.annotation.RestController
import java.util.UUID

@RestController
class UserController : UsersApi {
    override fun getUserById(id: UUID): ResponseEntity<User> {
        val user = if (id.toString().startsWith("a")) {
            User(id = id.toString(), name = "Alice")
        } else null

        return user?.let { ResponseEntity.ok(it) }
            ?: ResponseEntity.notFound().build()
    }
}
```

üëâ Flow: **Spec ‚Üí Codegen ‚Üí Interface ‚Üí Implementation**. All teams use the same API definition.

---

## üìå Best Practices

* **Keep the spec small**: Don't model everything upfront, but expand incrementally.
* **Consistent names**: API paths, models, enums ‚Üí consistent naming convention.
* **Security**: Define security schemes (OAuth2, Bearer JWT) right in the spec.
* **Documentation**: Use Swagger UI directly in the service ‚Äì developers get immediate feedback.

<Admonition type="tip" title="API-First pays off">
The extra effort at the beginning pays off many times over: Consistent interfaces, less friction between teams, faster development.
</Admonition>

---

## üìå Conclusion

API-first with OpenAPI and Kotlin + Spring Boot means: **interface first, code second**.
Generators for stubs & clients make the process reproducible, the documentation always stays up to date, and microservices can be integrated faster.