---

slug: api-first-springboot-kotlin
title: "API-First mit Spring Boot & Kotlin"
authors: brigitte
tags: [spring-boot, kotlin, openapi, microservices, codegen, api-first]
date: 2025-02-10
description: "Wie ich Microservices nach OpenAPI designe und automatisch Clients & Server-Stubs generiere ‚Äì Lessons Learned in Kotlin."
---

import Admonition from '@theme/Admonition';

Microservices sollen **konsistente Schnittstellen** bieten ‚Äì und zwar unabh√§ngig von der Programmiersprache.
API-First bedeutet: **erst das OpenAPI-Schema**, dann Code, Doku & Clients.
<!--truncate-->
Das verhindert, dass API-Definitionen veralten oder als ‚ÄûBeiprodukt‚Äú nachgezogen werden.

---

## üß© Workflow: API-First in der Praxis

1. **Design**: OpenAPI-Spec (`.yaml`) mit Stoplight, Swagger Editor oder VS Code Plugin.
2. **Validieren**: Linter (z. B. Spectral) und CI-Checks.
3. **Codegen**: Server-Stubs & Client-SDKs aus der Spec generieren.
4. **Implementieren**: Business-Logik in Kotlin, Interface bleibt stabil.
5. **Docs**: Swagger UI oder ReDoc aus der gleichen Spec.

---

## ‚öôÔ∏è Setup: OpenAPI Generator in Kotlin

**`build.gradle.kts`**

```kotlin
plugins {
    id("org.springframework.boot") version "3.3.0"
    id("io.spring.dependency-management") version "1.1.5"
    kotlin("jvm") version "1.9.24"
    kotlin("plugin.spring") version "1.9.24"
    id("org.openapi.generator") version "7.5.0"
}

openApiGenerate {
    generatorName.set("kotlin-spring")
    inputSpec.set("$rootDir/api/openapi.yaml")
    outputDir.set("$buildDir/generated")
    apiPackage.set("com.example.api")
    modelPackage.set("com.example.api.model")
    configOptions.set(
        mapOf(
            "interfaceOnly" to "true",
            "useSpringBoot3" to "true",
            "reactive" to "false"
        )
    )
}
```

üëâ Ergebnis:

* **API-Interfaces** als Kotlin-Interfaces (Controller-Skeletons)
* **DTOs** im `model`-Package

---

## üöß Lessons Learned

### 1. Interface-Only ist Gold wert

* Nur Interfaces generieren, Implementierung bleibt **sauber im eigenen Code**.
* Keine Merge-Konflikte beim erneuten Generieren.

### 2. DTOs strikt nutzen

* DTOs aus `model` sind **Transport-Objekte** ‚Äì keine Business-Entities.
* Vermeide ‚Äûsmarte‚Äú Logik in DTOs, halte sie flach.

### 3. Versionierung & Backward Compatibility

* OpenAPI als **Single Source of Truth** in Git versionieren.
* Breaking Changes nur mit neuer API-Version (`/v2/...`).

### 4. CI/CD-Checks

* OpenAPI Spec validieren in jedem PR (`spectral lint`).
* Codegen im CI pr√ºfen, ob alles aktuell ist (`git diff` auf generated code).

---

## üì¶ Client-Generierung

Mit OpenAPI Generator lassen sich auch **Clients** f√ºr andere Sprachen erstellen:

```bash
openapi-generator-cli generate \
  -i api/openapi.yaml \
  -g typescript-fetch \
  -o clients/ts
```

* Frontend nutzt `typescript-fetch` oder `typescript-axios`.
* Andere Services k√∂nnen `java`, `python`, `go` SDKs beziehen.
* Einheitliche API garantiert Konsistenz √ºber den Stack hinweg.

---

## üîó Mini-Beispiel: User API End-to-End

### 1. OpenAPI Spec (gek√ºrzt)

**`api/openapi.yaml`**

```yaml
openapi: 3.0.3
info:
  title: User API
  version: 1.0.0
paths:
  /users/{id}:
    get:
      summary: Get user by ID
      parameters:
        - in: path
          name: id
          required: true
          schema:
            type: string
            format: uuid
      responses:
        '200':
          description: OK
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/User'
        '404':
          description: Not Found
components:
  schemas:
    User:
      type: object
      properties:
        id:
          type: string
          format: uuid
        name:
          type: string
```

### 2. Generiertes Interface (gek√ºrzt)

**`build/generated/com/example/api/UsersApi.kt`**

```kotlin
package com.example.api

import com.example.api.model.User
import org.springframework.http.ResponseEntity
import org.springframework.web.bind.annotation.PathVariable

interface UsersApi {
    fun getUserById(@PathVariable("id") id: java.util.UUID): ResponseEntity<User>
}
```

### 3. Kotlin-Implementierung

**`src/main/kotlin/com/example/controller/UserController.kt`**

```kotlin
package com.example.controller

import com.example.api.UsersApi
import com.example.api.model.User
import org.springframework.http.ResponseEntity
import org.springframework.web.bind.annotation.RestController
import java.util.UUID

@RestController
class UserController : UsersApi {
    override fun getUserById(id: UUID): ResponseEntity<User> {
        val user = if (id.toString().startsWith("a")) {
            User(id = id.toString(), name = "Alice")
        } else null

        return user?.let { ResponseEntity.ok(it) }
            ?: ResponseEntity.notFound().build()
    }
}
```

üëâ Flow: **Spec ‚Üí Codegen ‚Üí Interface ‚Üí Implementierung**. Alle Teams nutzen dieselbe API-Definition.

---

## üìå Best Practices

* **Keep the spec small**: nicht alles upfront modellieren, sondern inkrementell erweitern.
* **Namen konsistent**: API Paths, Models, Enums ‚Üí konsistente Namenskonvention.
* **Sicherheit**: Security-Schemes (OAuth2, Bearer JWT) gleich in der Spec definieren.
* **Doku**: Nutze Swagger UI direkt im Service ‚Äì Entwickler haben sofort Feedback.

<Admonition type="tip" title="API-First lohnt sich">
Der Mehraufwand am Anfang zahlt sich mehrfach aus: Konsistente Schnittstellen, weniger Reibung zwischen Teams, schnellere Entwicklung.
</Admonition>

---

## üìå Fazit

API-First mit OpenAPI und Kotlin + Spring Boot bedeutet: **erst Schnittstelle, dann Code**.
Mit Generatoren f√ºr Stubs & Clients wird der Prozess reproduzierbar, die Doku bleibt immer aktuell und Microservices k√∂nnen schneller integriert werden.
